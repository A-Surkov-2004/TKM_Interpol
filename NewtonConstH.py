
cycles = 100  # Максимальное количество итераций уточненияя (но обычно заканчивает раньше)
close = 3  # Определяет, что мы считаем за "Близко к концу таблицы" (номер с конца)


def get():  # Инпут таблицы (не тестировался)
    n = int(input("Введите количество известных пар x y(x)"))
    print("Введите ", n, " пар {x y(x)} \n(каждая пара на отдельной строке)")
    v = [n]

    for i in range(n):
        s = input()
        s.split()
        v[i] = [s[0], s[1]]

    return v


def getX():  # инпут Х для поиска (не тестировался)
    n = int(input("Введите количество Х, У от которых необходимо найти"))
    xv = [n]
    print("Введите " + str(n) + " значений Х \n(каждое значение на отдельной строке)")
    for i in range(n):
        xv[n] = int(input())
    return xv


def solve(v, xv):
    # v - массив пар [x,y]
    allAns = []
    for X in xv:
        dif = X - v[0][0]
        h = abs(v[0][0] - v[1][0])
        x0 = v[0][0]
        y0 = v[0][1]
        i0 = 0
        index = 0

        for i in v:  # find x0 y0
            if abs(X - i[0]) < dif:
                x0 = i[0]
                y0 = i[1]
                i0 = index
                dif = abs(X - i[0])
            index += 1

        q = (X - x0) / h

        global cycles
        allDy = [[]] * (cycles + 1)  # allDy массив массивов дельта-ириков. Индекс равен степени дельты. Каждая
        # следующая дельта содержит на 1 элемент меньше передыдущей

        for i in v:  # v - массив пар [x,y]
            allDy[0].append(i[1])  # вносим в allDy[0] наши y
        for i in range(1, cycles + 1):  # подсчёт всех dy со всеми степенями
            allDy[i] = [0] * (len(v) - i)
            for j in range(len(allDy[i])):
                allDy[i][j] = allDy[i - 1][j + 1] - allDy[i - 1][j]

        print(allDy)  # дебажный лог, можно удалить

        global close  # задаётся в верху программы
        isClose = False
        if len(v) - i0 < close:  # если наш х0 внизу таблицы, используем слегка другой метод
            isClose = True

        ans = y0  # нулевая итерация цикла
        for i in range(1, cycles + 1):
            multiQ = 1  # здесь будем считать произведения q, q-1, q-2...
            fact = 1  # а здесь факториал
            for j in range(i):
                if isClose:
                    multiQ *= (q + j)  # Метод, если х0 снизу таблицы
                else:
                    multiQ *= (q - j)  # Стандартный метод
                fact *= j + 1

            if (not isClose and len(allDy[i])) > i0 or (isClose and i0 > 0):
                # ^ Если стандартный метод - смотрим, что нам есть откуда брать данные в allDy,
                # Иначе (обратный метод) - не уходим в отрицательные индексы.
                # true - решаем. false - пишем лог и выходим. Дальнейшее уточнение невозможно.
                if isClose:
                    i0 -= 1  # метод при x0 в конце таблицы
                newAns = (multiQ / fact) * allDy[i][i0]  # Уточнение Y, полученное на этой итерации
            else:
                print(len(allDy[i]), " ", i0)   # print - дебажный лог, можно удалить. break НАДО оставить.
                break

            ans += newAns  # накапливаем наши "уточнения"
        allAns.append("Y(" + str(X) + ") = " + str(ans))
    for i in allAns:
        print(i)


def test():     # Удобный способ захардкоженного инпута (запускается внизу программы)
    v = [[1.215, 0.106044],
         [1.22, 0.113276],
         [1.225, 0.119671],
         [1.23, 0.125324],
         [1.235, 0.130328],
         [1.24, 0.134776],
         [1.245, 0.138759],
         [1.25, 0.142367],
         [1.255, 0.145688],
         [1.26, 0.148809],
         ]
    vx = [1.2273, 1.253, 1.21, 1.2638]
    solve(v, vx)


def main():
    solve(get(), getX())


test()
